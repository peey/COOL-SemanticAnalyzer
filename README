Write-up for PA3
----------------

# Overview

There are two phases to the semantic checks

## Phase 1

Here we just go through all the classes declared by the programmer and make a map between class names (symbols) and class body. 

This is done because in the entire program, the classes are refered to using their names and not by passing the actual class object. This is close to how even in the AST, various places like parameter declarations all refer to the class by the name.

This also powers the `assert_type_exists` method which is used in the other two phases.


## Phase 2

I've implemented an InheritanceTree class which holds the parent-child relation between classes. The design is clean and lets you get things like chain of ancestors (useful for attribute initialization) pretty easily.

Here we use DFS to detect dependency cycles, and when there are none we start loading the classes into an inheritancetree by processing the ancestors first. 

As we are building the inheritance tree, we process the features of the class and load them into identifier and method environments on a per-class basis.

We also simultaneously class the type inference 


We need to expose a few members of the type "Class_" since we need access to parent and current class information to build up the inheritance tree. 

Next, we initialize the type environments O and M (TypeDeclarations->identifiers, TypeDeclarations->methods, respectively) by walking through class features. Each feature (attr and method) adds itself to the passed environment.

This is done in a way that a parent class is processed before a class which inherits it. If there is a cylcic dependency, it is found and reported. This is done by jumping to find and process the definition of the parent class. In case of cyclic dependency, we'll eventually jump to the initial attribute which we started with. In this case, we'll be able to detect this via a set which is being maintained which keeps a track of queued classes to be processed.

After this annotating the AST with correct types is as straightforward as implementing all the inference rules in the cool manual.

We also handle SELF_TYPE and are able to recover from type errors by using the strategy of assigning `No_type` to the expressions which give a type error. This is done in ClassTable::is_supertype_of as a special case, and in general when two types are present, `is_supertype_of` simply look at the tree and finds if the supertype is an ancestor of the subtype.

least upper bound is found by following the lowest common ancestor algorithm (with adjustments for No_type and SELF_TYPE).

The failing test cases are mostly those which require duplicate name / declaration checking. I also detect all the type errors, but typeerror test cases are failing.

Changes since backpack submission
 - Added remaining typecheck rules (let, block, typcase, branch, loop, cond, dispatch, static_dispatch, assign)
 - Add `is_subtype_of` and `lowest_common_ancestor` (least upper bound) routines
 - Detect cyclic dependencies, absence of main class 
