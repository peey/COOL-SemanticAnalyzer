Write-up for PA3
----------------

I've implemented an InheritanceTree class which holds the parent-child relation between classes. The design is clean and lets you get things like chain of ancestors (useful for attribute initialization) pretty easily.

We need to expose a few members of the type "Class_" since we need access to parent and current class information to build up the inheritance tree. 

Next, we initialize the type environments O and M (TypeDeclarations->identifiers, TypeDeclarations->methods, respectively) by walking through class features.

This is done so that a parent class is processed before a class which inherits it. If there is a cylcic dependency, it is found and reported.

After this annotating the AST with correct types is as straightforward as implementing all the inference rules.

We also handle SELF_TYPE and are able to recover from type errors by using the strategy of assigning `No_type` to the expressions which give a type error. This is done in ClassTable::is_supertype_of which does this with the help of inheritance tree.

Changes since backpack submission
 - Added remaining typecheck rules (let, block, typcase, branch, loop, cond, dispatch, static_dispatch, assign)
 - Add `is_subtype_of` and `lowest_common_ancestor` (least upper bound) routines
 - Detect cyclic dependencies, absence of main class 
