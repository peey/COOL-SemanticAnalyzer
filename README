Write-up for PA3
----------------

I've implemented an InheritanceTree class which holds the parent-child relation between classes. The design is clean and lets you get things like chain of ancestors (useful for attribute initialization) pretty easily.

We need to expose a few members of the type "Class_" since we need access to parent and current class information to build up the inheritance tree. 

Next, we initialize the type environments O and M (TypeDeclarations->identifiers, TypeDeclarations->methods, respectively) by walking through class features. Each feature (attr and method) adds itself to the passed environment.

This is done in a way that a parent class is processed before a class which inherits it. If there is a cylcic dependency, it is found and reported. This is done by jumping to find and process the definition of the parent class. In case of cyclic dependency, we'll eventually jump to the initial attribute which we started with. In this case, we'll be able to detect this via a set which is being maintained which keeps a track of queued classes to be processed.

After this annotating the AST with correct types is as straightforward as implementing all the inference rules in the cool manual.

We also handle SELF_TYPE and are able to recover from type errors by using the strategy of assigning `No_type` to the expressions which give a type error. This is done in ClassTable::is_supertype_of as a special case, and in general when two types are present, `is_supertype_of` simply look at the tree and finds if the supertype is an ancestor of the subtype.

least upper bound is found by following the lowest common ancestor algorithm (with adjustments for No_type and SELF_TYPE).

The failing test cases are mostly those which require duplicate name / declaration checking. I also detect all the type errors, but typeerror test cases are failing.

Changes since backpack submission
 - Added remaining typecheck rules (let, block, typcase, branch, loop, cond, dispatch, static_dispatch, assign)
 - Add `is_subtype_of` and `lowest_common_ancestor` (least upper bound) routines
 - Detect cyclic dependencies, absence of main class 
